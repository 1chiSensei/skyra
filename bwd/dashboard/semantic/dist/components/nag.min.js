/*!
 * # Semantic UI 2.2.9 - Nag
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, o, t, i) {
    o = void 0 !== o && o.Math == Math ? o : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.nag = function (t) {
        let i,
            n = e(this),
            s = n.selector || "",
            a = (new Date()).getTime(),
            r = [],
            d = arguments[0],
            l = typeof d === "string",
            c = [].slice.call(arguments, 1); return n.each(function () {
                let n,
                    g = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.nag.settings, t) : e.extend({}, e.fn.nag.settings),
                    u = (g.className, g.selector),
                    m = g.error,
                    f = g.namespace,
                    p = `.${f}`,
                    v = `${f}-module`,
                    h = e(this),
                    b = (h.find(u.close), e(g.context ? g.context : "body")),
                    y = this,
                    k = h.data(v); o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame; n = { initialize() { n.verbose("Initializing element"), h.on(`click${p}`, u.close, n.dismiss).data(v, n), g.detachable && h.parent()[0] !== b[0] && h.detach().prependTo(b), g.displayTime > 0 && setTimeout(n.hide, g.displayTime), n.show(); },
                        destroy() { n.verbose("Destroying instance"), h.removeData(v).off(p); },
                        show() { n.should.show() && !h.is(":visible") && (n.debug("Showing nag", g.animation.show), g.animation.show == "fade" ? h.fadeIn(g.duration, g.easing) : h.slideDown(g.duration, g.easing)); },
                        hide() { n.debug("Showing nag", g.animation.hide), g.animation.show == "fade" ? h.fadeIn(g.duration, g.easing) : h.slideUp(g.duration, g.easing); },
                        onHide() { n.debug("Removing nag", g.animation.hide), h.remove(), g.onHide && g.onHide(); },
                        dismiss(e) { g.storageMethod && n.storage.set(g.key, g.value), n.hide(), e.stopImmediatePropagation(), e.preventDefault(); },
                        should: { show() { return g.persist ? (n.debug("Persistent nag is set, can show nag"), !0) : n.storage.get(g.key) != g.value.toString() ? (n.debug("Stored value is not set, can show nag", n.storage.get(g.key)), !0) : (n.debug("Stored value is set, cannot show nag", n.storage.get(g.key)), !1); } },
                        get: { storageOptions() { const e = {}; return g.expires && (e.expires = g.expires), g.domain && (e.domain = g.domain), g.path && (e.path = g.path), e; } },
                        clear() { n.storage.remove(g.key); },
                        storage: { set(t, i) { const s = n.get.storageOptions(); if (g.storageMethod == "localstorage" && void 0 !== o.localStorage)o.localStorage.setItem(t, i), n.debug("Value stored using local storage", t, i); else if (g.storageMethod == "sessionstorage" && void 0 !== o.sessionStorage)o.sessionStorage.setItem(t, i), n.debug("Value stored using session storage", t, i); else { if (void 0 === e.cookie) return void n.error(m.noCookieStorage); e.cookie(t, i, s), n.debug("Value stored using cookie", t, i, s); } }, get(t, i) { let s; return g.storageMethod == "localstorage" && void 0 !== o.localStorage ? s = o.localStorage.getItem(t) : g.storageMethod == "sessionstorage" && void 0 !== o.sessionStorage ? s = o.sessionStorage.getItem(t) : void 0 !== e.cookie ? s = e.cookie(t) : n.error(m.noCookieStorage), s != "undefined" && s != "null" && void 0 !== s && s !== null || (s = void 0), s; }, remove(t) { const i = n.get.storageOptions(); g.storageMethod == "localstorage" && void 0 !== o.localStorage ? o.localStorage.removeItem(t) : g.storageMethod == "sessionstorage" && void 0 !== o.sessionStorage ? o.sessionStorage.removeItem(t) : void 0 !== e.cookie ? e.removeCookie(t, i) : n.error(m.noStorage); } },
                        setting(o, t) { if (n.debug("Changing setting", o, t), e.isPlainObject(o))e.extend(!0, g, o); else { if (void 0 === t) return g[o]; e.isPlainObject(g[o]) ? e.extend(!0, g[o], t) : g[o] = t; } },
                        internal(o, t) { if (e.isPlainObject(o))e.extend(!0, n, o); else { if (void 0 === t) return n[o]; n[o] = t; } },
                        debug() { !g.silent && g.debug && (g.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${g.name}:`), n.debug.apply(console, arguments))); },
                        verbose() { !g.silent && g.verbose && g.debug && (g.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${g.name}:`), n.verbose.apply(console, arguments))); },
                        error() { g.silent || (n.error = Function.prototype.bind.call(console.error, console, `${g.name}:`), n.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let o,
                                t,
                                i; g.performance && (o = (new Date()).getTime(), i = a || o, t = o - i, a = o, r.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: y, "Execution Time": t })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
                        },
                            display() {
                                let o = `${g.name}:`,
                                    t = 0; a = !1, clearTimeout(n.performance.timer), e.each(r, (e, o) => { t += o["Execution Time"]; }), o += ` ${t}ms`, s && (o += ` '${s}'`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(o), console.table ? console.table(r) : e.each(r, (e, o) => { console.log(`${o.Name}: ${o["Execution Time"]}ms`); }), console.groupEnd()), r = [];
                            } },
                        invoke(o, t, s) {
                            let a,
                                r,
                                d,
                                l = k; return t = t || c, s = y || s, typeof o === "string" && void 0 !== l && (o = o.split(/[\. ]/), a = o.length - 1, e.each(o, (t, i) => { const s = t != a ? i + o[t + 1].charAt(0).toUpperCase() + o[t + 1].slice(1) : o; if (e.isPlainObject(l[s]) && t != a)l = l[s]; else { if (void 0 !== l[s]) return r = l[s], !1; if (!e.isPlainObject(l[i]) || t == a) return void 0 !== l[i] ? (r = l[i], !1) : (n.error(m.method, o), !1); l = l[i]; } })), e.isFunction(r) ? d = r.apply(s, t) : void 0 !== r && (d = r), e.isArray(i) ? i.push(d) : void 0 !== i ? i = [i, d] : void 0 !== d && (i = d), r;
                        } }, l ? (void 0 === k && n.initialize(), n.invoke(d)) : (void 0 !== k && k.invoke("destroy"), n.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.nag.settings = { name: "Nag", silent: !1, debug: !1, verbose: !1, performance: !0, namespace: "Nag", persist: !1, displayTime: 0, animation: { show: "slide", hide: "slide" }, context: !1, detachable: !1, expires: 30, domain: !1, path: "/", storageMethod: "cookie", key: "nag", value: "dismiss", error: { noCookieStorage: "$.cookie is not included. A storage solution is required.", noStorage: "Neither $.cookie or store is defined. A storage solution is required for storing state", method: "The method you called is not defined." }, className: { bottom: "bottom", fixed: "fixed" }, selector: { close: ".close.icon" }, speed: 500, easing: "easeOutQuad", onHide() {} }, e.extend(e.easing, { easeOutQuad(e, o, t, i, n) { return -i * (o /= n) * (o - 2) + t; } });
}(jQuery, window, document));
