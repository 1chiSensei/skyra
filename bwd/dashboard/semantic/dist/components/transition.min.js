/*!
 * # Semantic UI 2.2.9 - Transition
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (n, i, e, t) {
    i = void 0 !== i && i.Math == Math ? i : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), n.fn.transition = function () {
        let t,
            a = n(this),
            o = a.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments,
            d = l[0],
            u = [].slice.call(arguments, 1),
            c = typeof d === "string"; i.requestAnimationFrame || i.mozRequestAnimationFrame || i.webkitRequestAnimationFrame || i.msRequestAnimationFrame; return a.each(function (i) {
                let m,
                    f,
                    p,
                    g,
                    v,
                    b,
                    y,
                    h,
                    w,
                    C = n(this),
                    A = this; w = { initialize() { m = w.get.settings.apply(A, l), g = m.className, p = m.error, v = m.metadata, h = `.${m.namespace}`, y = `module-${m.namespace}`, f = C.data(y) || w, b = w.get.animationEndEvent(), c && (c = w.invoke(d)), c === !1 && (w.verbose("Converted arguments into settings object", m), m.interval ? w.delay(m.animate) : w.animate(), w.instantiate()); },
                        instantiate() { w.verbose("Storing instance of module", w), f = w, C.data(y, f); },
                        destroy() { w.verbose("Destroying previous module for", A), C.removeData(y); },
                        refresh() { w.verbose("Refreshing display type on next animation"), delete w.displayType; },
                        forceRepaint() {
                            w.verbose("Forcing element repaint"); let n = C.parent(),
                                i = C.next(); i.length === 0 ? C.detach().appendTo(n) : C.detach().insertBefore(i);
                        },
                        repaint() { w.verbose("Repainting element"); A.offsetWidth; },
                        delay(n) {
                            let e,
                                t,
                                o = w.get.animationDirection(); o || (o = w.can.transition() ? w.get.direction() : "static"), n = void 0 !== n ? n : m.interval, e = m.reverse == "auto" && o == g.outward, t = e || m.reverse == 1 ? (a.length - i) * m.interval : i * m.interval, w.debug("Delaying animation by", t), setTimeout(w.animate, t);
                        },
                        animate(n) { if (m = n || m, !w.is.supported()) return w.error(p.support), !1; if (w.debug("Preparing animation", m.animation), w.is.animating()) { if (m.queue) return !m.allowRepeats && w.has.direction() && w.is.occurring() && w.queuing !== !0 ? w.debug("Animation is currently occurring, preventing queueing same animation", m.animation) : w.queue(m.animation), !1; if (!m.allowRepeats && w.is.occurring()) return w.debug("Animation is already occurring, will not execute repeated animation", m.animation), !1; w.debug("New animation started, completing previous early", m.animation), f.complete(); }w.can.animate() ? w.set.animating(m.animation) : w.error(p.noAnimation, m.animation, A); },
                        reset() { w.debug("Resetting animation to beginning conditions"), w.remove.animationCallbacks(), w.restore.conditions(), w.remove.animating(); },
                        queue(n) { w.debug("Queueing animation of", n), w.queuing = !0, C.one(`${b}.queue${h}`, function () { w.queuing = !1, w.repaint(), w.animate.apply(this, m); }); },
                        complete(n) { w.debug("Animation complete", m.animation), w.remove.completeCallback(), w.remove.failSafe(), w.is.looping() || (w.is.outward() ? (w.verbose("Animation is outward, hiding element"), w.restore.conditions(), w.hide()) : w.is.inward() ? (w.verbose("Animation is outward, showing element"), w.restore.conditions(), w.show()) : (w.verbose("Static animation completed"), w.restore.conditions(), m.onComplete.call(A))); },
                        force: { visible() {
                            let n = C.attr("style"),
                                i = w.get.userStyle(),
                                e = w.get.displayType(),
                                t = `${i}display: ${e} !important;`,
                                a = C.css("display"),
                                o = void 0 === n || n === ""; a !== e ? (w.verbose("Overriding default display to show element", e), C.attr("style", t)) : o && C.removeAttr("style");
                        },
                            hidden() {
                                let n = C.attr("style"),
                                    i = C.css("display"),
                                    e = void 0 === n || n === ""; i === "none" || w.is.hidden() ? e && C.removeAttr("style") : (w.verbose("Overriding default display to hide element"), C.css("display", "none"));
                            } },
                        has: { direction(i) { let e = !1; return i = i || m.animation, typeof i === "string" && (i = i.split(" "), n.each(i, (n, i) => { i !== g.inward && i !== g.outward || (e = !0); })), e; }, inlineDisplay() { const i = C.attr("style") || ""; return n.isArray(i.match(/display.*?;/, "")); } },
                        set: { animating(n) { let i; w.remove.completeCallback(), n = n || m.animation, i = w.get.animationClass(n), w.save.animation(i), w.force.visible(), w.remove.hidden(), w.remove.direction(), w.start.animation(i); }, duration(n, i) { i = i || m.duration, ((i = typeof i === "number" ? `${i}ms` : i) || i === 0) && (w.verbose("Setting animation duration", i), C.css({ "animation-duration": i })); }, direction(n) { n = n || w.get.direction(), n == g.inward ? w.set.inward() : w.set.outward(); }, looping() { w.debug("Transition set to loop"), C.addClass(g.looping); }, hidden() { C.addClass(g.transition).addClass(g.hidden); }, inward() { w.debug("Setting direction to inward"), C.removeClass(g.outward).addClass(g.inward); }, outward() { w.debug("Setting direction to outward"), C.removeClass(g.inward).addClass(g.outward); }, visible() { C.addClass(g.transition).addClass(g.visible); } },
                        start: { animation(n) { n = n || w.get.animationClass(), w.debug("Starting tween", n), C.addClass(n).one(`${b}.complete${h}`, w.complete), m.useFailSafe && w.add.failSafe(), w.set.duration(m.duration), m.onStart.call(A); } },
                        save: { animation(n) { w.cache || (w.cache = {}), w.cache.animation = n; }, displayType(n) { n !== "none" && C.data(v.displayType, n); }, transitionExists(i, e) { n.fn.transition.exists[i] = e, w.verbose("Saving existence of transition", i, e); } },
                        restore: { conditions() { const n = w.get.currentAnimation(); n && (C.removeClass(n), w.verbose("Removing animation class", w.cache)), w.remove.duration(); } },
                        add: { failSafe() { const n = w.get.duration(); w.timer = setTimeout(() => { C.triggerHandler(b); }, n + m.failSafeDelay), w.verbose("Adding fail safe timer", w.timer); } },
                        remove: { animating() { C.removeClass(g.animating); }, animationCallbacks() { w.remove.queueCallback(), w.remove.completeCallback(); }, queueCallback() { C.off(`.queue${h}`); }, completeCallback() { C.off(`.complete${h}`); }, display() { C.css("display", ""); }, direction() { C.removeClass(g.inward).removeClass(g.outward); }, duration() { C.css("animation-duration", ""); }, failSafe() { w.verbose("Removing fail safe timer", w.timer), w.timer && clearTimeout(w.timer); }, hidden() { C.removeClass(g.hidden); }, visible() { C.removeClass(g.visible); }, looping() { w.debug("Transitions are no longer looping"), w.is.looping() && (w.reset(), C.removeClass(g.looping)); }, transition() { C.removeClass(g.visible).removeClass(g.hidden); } },
                        get: { settings(i, e, t) { return typeof i === "object" ? n.extend(!0, {}, n.fn.transition.settings, i) : typeof t === "function" ? n.extend({}, n.fn.transition.settings, { animation: i, onComplete: t, duration: e }) : typeof e === "string" || typeof e === "number" ? n.extend({}, n.fn.transition.settings, { animation: i, duration: e }) : typeof e === "object" ? n.extend({}, n.fn.transition.settings, e, { animation: i }) : typeof e === "function" ? n.extend({}, n.fn.transition.settings, { animation: i, onComplete: e }) : n.extend({}, n.fn.transition.settings, { animation: i }); },
                            animationClass(n) {
                                let i = n || m.animation,
                                    e = w.can.transition() && !w.has.direction() ? `${w.get.direction()} ` : ""; return `${g.animating} ${g.transition} ${e}${i}`;
                            },
                            currentAnimation() { return !(!w.cache || void 0 === w.cache.animation) && w.cache.animation; },
                            currentDirection() { return w.is.inward() ? g.inward : g.outward; },
                            direction() { return w.is.hidden() || !w.is.visible() ? g.inward : g.outward; },
                            animationDirection(i) { let e; return i = i || m.animation, typeof i === "string" && (i = i.split(" "), n.each(i, (n, i) => { i === g.inward ? e = g.inward : i === g.outward && (e = g.outward); })), !!e && e; },
                            duration(n) { return n = n || m.duration, n === !1 && (n = C.css("animation-duration") || 0), typeof n === "string" ? n.indexOf("ms") > -1 ? parseFloat(n) : 1e3 * parseFloat(n) : n; },
                            displayType(n) { return n = void 0 === n || n, m.displayType ? m.displayType : (n && void 0 === C.data(v.displayType) && w.can.transition(!0), C.data(v.displayType)); },
                            userStyle(n) { return n = n || C.attr("style") || "", n.replace(/display.*?;/, ""); },
                            transitionExists(i) { return n.fn.transition.exists[i]; },
                            animationStartEvent() {
                                let n,
                                    i = e.createElement("div"),
                                    t = { animation: "animationstart", OAnimation: "oAnimationStart", MozAnimation: "mozAnimationStart", WebkitAnimation: "webkitAnimationStart" }; for (n in t) if (void 0 !== i.style[n]) return t[n]; return !1;
                            },
                            animationEndEvent() {
                                let n,
                                    i = e.createElement("div"),
                                    t = { animation: "animationend", OAnimation: "oAnimationEnd", MozAnimation: "mozAnimationEnd", WebkitAnimation: "webkitAnimationEnd" }; for (n in t) if (void 0 !== i.style[n]) return t[n]; return !1;
                            } },
                        can: { transition(i) {
                            let e,
                                t,
                                a,
                                o,
                                r,
                                s,
                                l = m.animation,
                                d = w.get.transitionExists(l),
                                u = w.get.displayType(!1); if (void 0 === d || i) { if (w.verbose("Determining whether animation exists"), e = C.attr("class"), t = C.prop("tagName"), a = n(`<${t} />`).addClass(e).insertAfter(C), o = a.addClass(l).removeClass(g.inward).removeClass(g.outward).addClass(g.animating).addClass(g.transition).css("animationName"), r = a.addClass(g.inward).css("animationName"), u || (u = a.attr("class", e).removeAttr("style").removeClass(g.hidden).removeClass(g.visible).show().css("display"), w.verbose("Determining final display state", u), w.save.displayType(u)), a.remove(), o != r)w.debug("Direction exists for animation", l), s = !0; else { if (o == "none" || !o) return void w.debug("No animation defined in css", l); w.debug("Static animation found", l, u), s = !1; }w.save.transitionExists(l, s); } return void 0 !== d ? d : s;
                        },
                            animate() { return void 0 !== w.can.transition(); } },
                        is: { animating() { return C.hasClass(g.animating); }, inward() { return C.hasClass(g.inward); }, outward() { return C.hasClass(g.outward); }, looping() { return C.hasClass(g.looping); }, occurring(n) { return n = n || m.animation, n = `.${n.replace(" ", ".")}`, C.filter(n).length > 0; }, visible() { return C.is(":visible"); }, hidden() { return C.css("visibility") === "hidden"; }, supported() { return b !== !1; } },
                        hide() { w.verbose("Hiding element"), w.is.animating() && w.reset(), A.blur(), w.remove.display(), w.remove.visible(), w.set.hidden(), w.force.hidden(), m.onHide.call(A), m.onComplete.call(A); },
                        show(n) { w.verbose("Showing element", n), w.remove.hidden(), w.set.visible(), w.force.visible(), m.onShow.call(A), m.onComplete.call(A); },
                        toggle() { w.is.visible() ? w.hide() : w.show(); },
                        stop() { w.debug("Stopping current animation"), C.triggerHandler(b); },
                        stopAll() { w.debug("Stopping all animation"), w.remove.queueCallback(), C.triggerHandler(b); },
                        clear: { queue() { w.debug("Clearing animation queue"), w.remove.queueCallback(); } },
                        enable() { w.verbose("Starting animation"), C.removeClass(g.disabled); },
                        disable() { w.debug("Stopping animation"), C.addClass(g.disabled); },
                        setting(i, e) { if (w.debug("Changing setting", i, e), n.isPlainObject(i))n.extend(!0, m, i); else { if (void 0 === e) return m[i]; n.isPlainObject(m[i]) ? n.extend(!0, m[i], e) : m[i] = e; } },
                        internal(i, e) { if (n.isPlainObject(i))n.extend(!0, w, i); else { if (void 0 === e) return w[i]; w[i] = e; } },
                        debug() { !m.silent && m.debug && (m.performance ? w.performance.log(arguments) : (w.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), w.debug.apply(console, arguments))); },
                        verbose() { !m.silent && m.verbose && m.debug && (m.performance ? w.performance.log(arguments) : (w.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), w.verbose.apply(console, arguments))); },
                        error() { m.silent || (w.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), w.error.apply(console, arguments)); },
                        performance: { log(n) {
                            let i,
                                e,
                                t; m.performance && (i = (new Date()).getTime(), t = r || i, e = i - t, r = i, s.push({ Name: n[0], Arguments: [].slice.call(n, 1) || "", Element: A, "Execution Time": e })), clearTimeout(w.performance.timer), w.performance.timer = setTimeout(w.performance.display, 500);
                        },
                            display() {
                                let i = `${m.name}:`,
                                    e = 0; r = !1, clearTimeout(w.performance.timer), n.each(s, (n, i) => { e += i["Execution Time"]; }), i += ` ${e}ms`, o && (i += ` '${o}'`), a.length > 1 && (i += ` (${a.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(i), console.table ? console.table(s) : n.each(s, (n, i) => { console.log(`${i.Name}: ${i["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(i, e, a) {
                            let o,
                                r,
                                s,
                                l = f; return e = e || u, a = A || a, typeof i === "string" && void 0 !== l && (i = i.split(/[\. ]/), o = i.length - 1, n.each(i, (e, t) => { const a = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (n.isPlainObject(l[a]) && e != o)l = l[a]; else { if (void 0 !== l[a]) return r = l[a], !1; if (!n.isPlainObject(l[t]) || e == o) return void 0 !== l[t] && (r = l[t], !1); l = l[t]; } })), n.isFunction(r) ? s = r.apply(a, e) : void 0 !== r && (s = r), n.isArray(t) ? t.push(s) : void 0 !== t ? t = [t, s] : void 0 !== s && (t = s), void 0 !== r && r;
                        } }, w.initialize();
            }), void 0 !== t ? t : this;
    }, n.fn.transition.exists = {}, n.fn.transition.settings = { name: "Transition", silent: !1, debug: !1, verbose: !1, performance: !0, namespace: "transition", interval: 0, reverse: "auto", onStart() {}, onComplete() {}, onShow() {}, onHide() {}, useFailSafe: !0, failSafeDelay: 100, allowRepeats: !1, displayType: !1, animation: "fade", duration: !1, queue: !0, metadata: { displayType: "display" }, className: { animating: "animating", disabled: "disabled", hidden: "hidden", inward: "in", loading: "loading", looping: "looping", outward: "out", transition: "transition", visible: "visible" }, error: { noAnimation: "Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.", repeated: "That animation is already occurring, cancelling repeated animation", method: "The method you called is not defined", support: "This browser does not support CSS animations" } };
}(jQuery, window, document));
