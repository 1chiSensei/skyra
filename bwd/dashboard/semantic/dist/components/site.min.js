/*!
 * # Semantic UI 2.2.9 - Site
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, n, o, i) {
    e.site = e.fn.site = function (i) {
        let t,
            s,
            r = (new Date()).getTime(),
            a = [],
            c = arguments[0],
            l = typeof c === "string",
            u = [].slice.call(arguments, 1),
            d = e.isPlainObject(i) ? e.extend(!0, {}, e.site.settings, i) : e.extend({}, e.site.settings),
            m = d.namespace,
            g = d.error,
            f = `module-${m}`,
            b = e(o),
            p = b,
            v = this,
            h = p.data(f); return t = { initialize() { t.instantiate(); },
                instantiate() { t.verbose("Storing instance of site", t), h = t, p.data(f, t); },
                normalize() { t.fix.console(), t.fix.requestAnimationFrame(); },
                fix: { console() { t.debug("Normalizing window.console"), void 0 !== console && void 0 !== console.log || (t.verbose("Console not available, normalizing events"), t.disable.console()), void 0 !== console.group && void 0 !== console.groupEnd && void 0 !== console.groupCollapsed || (t.verbose("Console group not available, normalizing events"), n.console.group = function () {}, n.console.groupEnd = function () {}, n.console.groupCollapsed = function () {}), void 0 === console.markTimeline && (t.verbose("Mark timeline not available, normalizing events"), n.console.markTimeline = function () {}); }, consoleClear() { t.debug("Disabling programmatic console clearing"), n.console.clear = function () {}; }, requestAnimationFrame() { t.debug("Normalizing requestAnimationFrame"), void 0 === n.requestAnimationFrame && (t.debug("RequestAnimationFrame not available, normalizing event"), n.requestAnimationFrame = n.requestAnimationFrame || n.mozRequestAnimationFrame || n.webkitRequestAnimationFrame || n.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }); } },
                moduleExists(n) { return void 0 !== e.fn[n] && void 0 !== e.fn[n].settings; },
                enabled: { modules(n) { const o = []; return n = n || d.modules, e.each(n, (e, n) => { t.moduleExists(n) && o.push(n); }), o; } },
                disabled: { modules(n) { const o = []; return n = n || d.modules, e.each(n, (e, n) => { t.moduleExists(n) || o.push(n); }), o; } },
                change: { setting(n, o, i, s) {
                    i = typeof i === "string" ? i === "all" ? d.modules : [i] : i || d.modules, s = void 0 === s || s, e.each(i, (i, r) => {
                        let a,
                            c = !t.moduleExists(r) || (e.fn[r].settings.namespace || !1); t.moduleExists(r) && (t.verbose("Changing default setting", n, o, r), e.fn[r].settings[n] = o, s && c && (a = e(`:data(module-${c})`), a.length > 0 && (t.verbose("Modifying existing settings", a), a[r]("setting", n, o))));
                    });
                },
                    settings(n, o, i) { o = typeof o === "string" ? [o] : o || d.modules, i = void 0 === i || i, e.each(o, (o, s) => { let r; t.moduleExists(s) && (t.verbose("Changing default setting", n, s), e.extend(!0, e.fn[s].settings, n), i && m && (r = e(`:data(module-${m})`), r.length > 0 && (t.verbose("Modifying existing settings", r), r[s]("setting", n)))); }); } },
                enable: { console() { t.console(!0); }, debug(e, n) { e = e || d.modules, t.debug("Enabling debug for modules", e), t.change.setting("debug", !0, e, n); }, verbose(e, n) { e = e || d.modules, t.debug("Enabling verbose debug for modules", e), t.change.setting("verbose", !0, e, n); } },
                disable: { console() { t.console(!1); }, debug(e, n) { e = e || d.modules, t.debug("Disabling debug for modules", e), t.change.setting("debug", !1, e, n); }, verbose(e, n) { e = e || d.modules, t.debug("Disabling verbose debug for modules", e), t.change.setting("verbose", !1, e, n); } },
                console(e) { if (e) { if (void 0 === h.cache.console) return void t.error(g.console); t.debug("Restoring console function"), n.console = h.cache.console; } else t.debug("Disabling console function"), h.cache.console = n.console, n.console = { clear() {}, error() {}, group() {}, groupCollapsed() {}, groupEnd() {}, info() {}, log() {}, markTimeline() {}, warn() {} }; },
                destroy() { t.verbose("Destroying previous site for", p), p.removeData(f); },
                cache: {},
                setting(n, o) { if (e.isPlainObject(n))e.extend(!0, d, n); else { if (void 0 === o) return d[n]; d[n] = o; } },
                internal(n, o) { if (e.isPlainObject(n))e.extend(!0, t, n); else { if (void 0 === o) return t[n]; t[n] = o; } },
                debug() { d.debug && (d.performance ? t.performance.log(arguments) : (t.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), t.debug.apply(console, arguments))); },
                verbose() { d.verbose && d.debug && (d.performance ? t.performance.log(arguments) : (t.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), t.verbose.apply(console, arguments))); },
                error() { t.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), t.error.apply(console, arguments); },
                performance: { log(e) {
                    let n,
                        o,
                        i; d.performance && (n = (new Date()).getTime(), i = r || n, o = n - i, r = n, a.push({ Element: v, Name: e[0], Arguments: [].slice.call(e, 1) || "", "Execution Time": o })), clearTimeout(t.performance.timer), t.performance.timer = setTimeout(t.performance.display, 500);
                },
                    display() {
                        let n = `${d.name}:`,
                            o = 0; r = !1, clearTimeout(t.performance.timer), e.each(a, (e, n) => { o += n["Execution Time"]; }), n += ` ${o}ms`, (void 0 !== console.group || void 0 !== console.table) && a.length > 0 && (console.groupCollapsed(n), console.table ? console.table(a) : e.each(a, (e, n) => { console.log(`${n.Name}: ${n["Execution Time"]}ms`); }), console.groupEnd()), a = [];
                    } },
                invoke(n, o, i) {
                    let r,
                        a,
                        c,
                        l = h; return o = o || u, i = v || i, typeof n === "string" && void 0 !== l && (n = n.split(/[\. ]/), r = n.length - 1, e.each(n, (o, i) => { const s = o != r ? i + n[o + 1].charAt(0).toUpperCase() + n[o + 1].slice(1) : n; if (e.isPlainObject(l[s]) && o != r)l = l[s]; else { if (void 0 !== l[s]) return a = l[s], !1; if (!e.isPlainObject(l[i]) || o == r) return void 0 !== l[i] ? (a = l[i], !1) : (t.error(g.method, n), !1); l = l[i]; } })), e.isFunction(a) ? c = a.apply(i, o) : void 0 !== a && (c = a), e.isArray(s) ? s.push(c) : void 0 !== s ? s = [s, c] : void 0 !== c && (s = c), a;
                } }, l ? (void 0 === h && t.initialize(), t.invoke(c)) : (void 0 !== h && t.destroy(), t.initialize()), void 0 !== s ? s : this;
    }, e.site.settings = { name: "Site", namespace: "site", error: { console: "Console cannot be restored, most likely it was overwritten outside of module", method: "The method you called is not defined." }, debug: !1, verbose: !1, performance: !0, modules: ["accordion", "api", "checkbox", "dimmer", "dropdown", "embed", "form", "modal", "nag", "popup", "rating", "shape", "sidebar", "state", "sticky", "tab", "transition", "visit", "visibility"], siteNamespace: "site", namespaceStub: { cache: {}, config: {}, sections: {}, section: {}, utilities: {} } }, e.extend(e.expr[":"], { data: e.expr.createPseudo ? e.expr.createPseudo(n => function (o) { return !!e.data(o, n); }) : function (n, o, i) { return !!e.data(n, i[3]); } });
}(jQuery, window, document));
