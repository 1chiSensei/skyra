/*!
 * # Semantic UI 2.2.9 - Shape
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, t, i, n) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.shape = function (n) {
        let a,
            o = e(this),
            r = (e("body"), (new Date()).getTime()),
            s = [],
            d = arguments[0],
            l = typeof d === "string",
            u = [].slice.call(arguments, 1),
            c = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return o.each(function () {
                let t,
                    g,
                    f,
                    m = o.selector || "",
                    h = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.shape.settings, n) : e.extend({}, e.fn.shape.settings),
                    p = h.namespace,
                    v = h.selector,
                    b = h.error,
                    x = h.className,
                    y = `.${p}`,
                    S = `module-${p}`,
                    w = e(this),
                    C = w.find(v.sides),
                    z = w.find(v.side),
                    W = !1,
                    F = this,
                    H = w.data(S); f = { initialize() { f.verbose("Initializing module for", F), f.set.defaultSide(), f.instantiate(); },
                        instantiate() { f.verbose("Storing instance of module", f), H = f, w.data(S, H); },
                        destroy() { f.verbose("Destroying previous module for", F), w.removeData(S).off(y); },
                        refresh() { f.verbose("Refreshing selector cache for", F), w = e(F), C = e(this).find(v.shape), z = e(this).find(v.side); },
                        repaint() { f.verbose("Forcing repaint event"); const e = C[0] || i.createElement("div"); e.offsetWidth; },
                        animate(e, i) { f.verbose("Animating box with properties", e), i = i || function (e) { f.verbose("Executing animation callback"), void 0 !== e && e.stopPropagation(), f.reset(), f.set.active(); }, h.beforeChange.call(g[0]), f.get.transitionEvent() ? (f.verbose("Starting CSS animation"), w.addClass(x.animating), C.css(e).one(f.get.transitionEvent(), i), f.set.duration(h.duration), c(() => { w.addClass(x.animating), t.addClass(x.hidden); })) : i(); },
                        queue(e) { f.debug("Queueing animation of", e), C.one(f.get.transitionEvent(), () => { f.debug("Executing queued animation"), setTimeout(() => { w.shape(e); }, 0); }); },
                        reset() { f.verbose("Animating states reset"), w.removeClass(x.animating).attr("style", "").removeAttr("style"), C.attr("style", "").removeAttr("style"), z.attr("style", "").removeAttr("style").removeClass(x.hidden), g.removeClass(x.animating).attr("style", "").removeAttr("style"); },
                        is: { complete() { return z.filter(`.${x.active}`)[0] == g[0]; }, animating() { return w.hasClass(x.animating); } },
                        set: { defaultSide() { t = w.find(`.${h.className.active}`), g = t.next(v.side).length > 0 ? t.next(v.side) : w.find(v.side).first(), W = !1, f.verbose("Active side set to", t), f.verbose("Next side set to", g); },
                            duration(e) { e = e || h.duration, e = typeof e === "number" ? `${e}ms` : e, f.verbose("Setting animation duration", e), (h.duration || h.duration === 0) && C.add(z).css({ "-webkit-transition-duration": e, "-moz-transition-duration": e, "-ms-transition-duration": e, "-o-transition-duration": e, "transition-duration": e }); },
                            currentStageSize() {
                                let e = w.find(`.${h.className.active}`),
                                    t = e.outerWidth(!0),
                                    i = e.outerHeight(!0); w.css({ width: t, height: i });
                            },
                            stageSize() {
                                let e = w.clone().addClass(x.loading),
                                    t = e.find(`.${h.className.active}`),
                                    i = W ? e.find(v.side).eq(W) : t.next(v.side).length > 0 ? t.next(v.side) : e.find(v.side).first(),
                                    n = h.width == "next" ? i.outerWidth(!0) : h.width == "initial" ? w.width() : h.width,
                                    a = h.height == "next" ? i.outerHeight(!0) : h.height == "initial" ? w.height() : h.height; t.removeClass(x.active), i.addClass(x.active), e.insertAfter(w), e.remove(), h.width != "auto" && (w.css("width", n + h.jitter), f.verbose("Specifying width during animation", n)), h.height != "auto" && (w.css("height", a + h.jitter), f.verbose("Specifying height during animation", a));
                            },
                            nextSide(e) { W = e, g = z.filter(e), W = z.index(g), g.length === 0 && (f.set.defaultSide(), f.error(b.side)), f.verbose("Next side manually set to", g); },
                            active() { f.verbose("Setting new side to active", g), z.removeClass(x.active), g.addClass(x.active), h.onChange.call(g[0]), f.set.defaultSide(); } },
                        flip: { up() { if (f.is.complete() && !f.is.animating() && !h.allowRepeats) return void f.debug("Side already visible", g); if (f.is.animating())f.queue("flip up"); else { f.debug("Flipping up", g); const e = f.get.transform.up(); f.set.stageSize(), f.stage.above(), f.animate(e); } }, down() { if (f.is.complete() && !f.is.animating() && !h.allowRepeats) return void f.debug("Side already visible", g); if (f.is.animating())f.queue("flip down"); else { f.debug("Flipping down", g); const e = f.get.transform.down(); f.set.stageSize(), f.stage.below(), f.animate(e); } }, left() { if (f.is.complete() && !f.is.animating() && !h.allowRepeats) return void f.debug("Side already visible", g); if (f.is.animating())f.queue("flip left"); else { f.debug("Flipping left", g); const e = f.get.transform.left(); f.set.stageSize(), f.stage.left(), f.animate(e); } }, right() { if (f.is.complete() && !f.is.animating() && !h.allowRepeats) return void f.debug("Side already visible", g); if (f.is.animating())f.queue("flip right"); else { f.debug("Flipping right", g); const e = f.get.transform.right(); f.set.stageSize(), f.stage.right(), f.animate(e); } }, over() { if (f.is.complete() && !f.is.animating() && !h.allowRepeats) return void f.debug("Side already visible", g); f.is.animating() ? f.queue("flip over") : (f.debug("Flipping over", g), f.set.stageSize(), f.stage.behind(), f.animate(f.get.transform.over())); }, back() { if (f.is.complete() && !f.is.animating() && !h.allowRepeats) return void f.debug("Side already visible", g); f.is.animating() ? f.queue("flip back") : (f.debug("Flipping back", g), f.set.stageSize(), f.stage.behind(), f.animate(f.get.transform.back())); } },
                        get: { transform: { up() { const e = { y: -((t.outerHeight(!0) - g.outerHeight(!0)) / 2), z: -(t.outerHeight(!0) / 2) }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(-90deg)` }; }, down() { const e = { y: -((t.outerHeight(!0) - g.outerHeight(!0)) / 2), z: -(t.outerHeight(!0) / 2) }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(90deg)` }; }, left() { const e = { x: -((t.outerWidth(!0) - g.outerWidth(!0)) / 2), z: -(t.outerWidth(!0) / 2) }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(90deg)` }; }, right() { const e = { x: -((t.outerWidth(!0) - g.outerWidth(!0)) / 2), z: -(t.outerWidth(!0) / 2) }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(-90deg)` }; }, over() { return { transform: `translateX(${{ x: -((t.outerWidth(!0) - g.outerWidth(!0)) / 2) }.x}px) rotateY(180deg)` }; }, back() { return { transform: `translateX(${{ x: -((t.outerWidth(!0) - g.outerWidth(!0)) / 2) }.x}px) rotateY(-180deg)` }; } },
                            transitionEvent() {
                                let e,
                                    t = i.createElement("element"),
                                    n = { transition: "transitionend", OTransition: "oTransitionEnd", MozTransition: "transitionend", WebkitTransition: "webkitTransitionEnd" }; for (e in n) if (void 0 !== t.style[e]) return n[e];
                            },
                            nextSide() { return t.next(v.side).length > 0 ? t.next(v.side) : w.find(v.side).first(); } },
                        stage: { above() { const e = { origin: (t.outerHeight(!0) - g.outerHeight(!0)) / 2, depth: { active: g.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; f.verbose("Setting the initial animation position as above", g, e), C.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), g.addClass(x.animating).css({ top: `${e.origin}px`, transform: `rotateX(90deg) translateZ(${e.depth.next}px)` }); },
                            below() { const e = { origin: (t.outerHeight(!0) - g.outerHeight(!0)) / 2, depth: { active: g.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; f.verbose("Setting the initial animation position as below", g, e), C.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), g.addClass(x.animating).css({ top: `${e.origin}px`, transform: `rotateX(-90deg) translateZ(${e.depth.next}px)` }); },
                            left() {
                                let e = { active: t.outerWidth(!0), next: g.outerWidth(!0) },
                                    i = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; f.verbose("Setting the initial animation position as left", g, i), C.css({ transform: `translateZ(-${i.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${i.depth.active}px)` }), g.addClass(x.animating).css({ left: `${i.origin}px`, transform: `rotateY(-90deg) translateZ(${i.depth.next}px)` });
                            },
                            right() {
                                let e = { active: t.outerWidth(!0), next: g.outerWidth(!0) },
                                    i = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; f.verbose("Setting the initial animation position as left", g, i), C.css({ transform: `translateZ(-${i.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${i.depth.active}px)` }), g.addClass(x.animating).css({ left: `${i.origin}px`, transform: `rotateY(90deg) translateZ(${i.depth.next}px)` });
                            },
                            behind() {
                                let e = { active: t.outerWidth(!0), next: g.outerWidth(!0) },
                                    i = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; f.verbose("Setting the initial animation position as behind", g, i), t.css({ transform: "rotateY(0deg)" }), g.addClass(x.animating).css({ left: `${i.origin}px`, transform: "rotateY(-180deg)" });
                            } },
                        setting(t, i) { if (f.debug("Changing setting", t, i), e.isPlainObject(t))e.extend(!0, h, t); else { if (void 0 === i) return h[t]; e.isPlainObject(h[t]) ? e.extend(!0, h[t], i) : h[t] = i; } },
                        internal(t, i) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === i) return f[t]; f[t] = i; } },
                        debug() { !h.silent && h.debug && (h.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${h.name}:`), f.debug.apply(console, arguments))); },
                        verbose() { !h.silent && h.verbose && h.debug && (h.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${h.name}:`), f.verbose.apply(console, arguments))); },
                        error() { h.silent || (f.error = Function.prototype.bind.call(console.error, console, `${h.name}:`), f.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                i,
                                n; h.performance && (t = (new Date()).getTime(), n = r || t, i = t - n, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: F, "Execution Time": i })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                        },
                            display() {
                                let t = `${h.name}:`,
                                    i = 0; r = !1, clearTimeout(f.performance.timer), e.each(s, (e, t) => { i += t["Execution Time"]; }), t += ` ${i}ms`, m && (t += ` '${m}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, i, n) {
                            let o,
                                r,
                                s,
                                d = H; return i = i || u, n = F || n, typeof t === "string" && void 0 !== d && (t = t.split(/[\. ]/), o = t.length - 1, e.each(t, (i, n) => { const a = i != o ? n + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(d[a]) && i != o)d = d[a]; else { if (void 0 !== d[a]) return r = d[a], !1; if (!e.isPlainObject(d[n]) || i == o) return void 0 !== d[n] && (r = d[n], !1); d = d[n]; } })), e.isFunction(r) ? s = r.apply(n, i) : void 0 !== r && (s = r), e.isArray(a) ? a.push(s) : void 0 !== a ? a = [a, s] : void 0 !== s && (a = s), r;
                        } }, l ? (void 0 === H && f.initialize(), f.invoke(d)) : (void 0 !== H && H.invoke("destroy"), f.initialize());
            }), void 0 !== a ? a : this;
    }, e.fn.shape.settings = { name: "Shape", silent: !1, debug: !1, verbose: !1, jitter: 0, performance: !0, namespace: "shape", width: "initial", height: "initial", beforeChange() {}, onChange() {}, allowRepeats: !1, duration: !1, error: { side: "You tried to switch to a side that does not exist.", method: "The method you called is not defined" }, className: { animating: "animating", hidden: "hidden", loading: "loading", active: "active" }, selector: { sides: ".sides", side: ".side" } };
}(jQuery, window, document));
