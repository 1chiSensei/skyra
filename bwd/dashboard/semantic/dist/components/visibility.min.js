/*!
 * # Semantic UI 2.2.9 - Visibility
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, o, n, t) {
    o = void 0 !== o && o.Math == Math ? o : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.visibility = function (t) {
        let i,
            s = e(this),
            c = s.selector || "",
            r = (new Date()).getTime(),
            a = [],
            l = arguments[0],
            d = typeof l === "string",
            u = [].slice.call(arguments, 1),
            f = s.length,
            v = 0; return s.each(function () {
                let s,
                    b,
                    m,
                    g,
                    p = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.visibility.settings, t) : e.extend({}, e.fn.visibility.settings),
                    h = p.className,
                    P = p.namespace,
                    x = p.error,
                    C = p.metadata,
                    y = `.${P}`,
                    R = `module-${P}`,
                    V = e(o),
                    S = e(this),
                    k = e(p.context),
                    T = (S.selector, S.data(R)),
                    O = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame || function (e) { setTimeout(e, 0); },
                    A = this,
                    z = !1; g = { initialize() { g.debug("Initializing", p), g.setup.cache(), g.should.trackChanges() && (p.type == "image" && g.setup.image(), p.type == "fixed" && g.setup.fixed(), p.observeChanges && g.observeChanges(), g.bind.events()), g.save.position(), g.is.visible() || g.error(x.visible, S), p.initialCheck && g.checkVisibility(), g.instantiate(); },
                        instantiate() { g.debug("Storing instance", g), S.data(R, g), T = g; },
                        destroy() { g.verbose("Destroying previous module"), m && m.disconnect(), b && b.disconnect(), V.off(`load${y}`, g.event.load).off(`resize${y}`, g.event.resize), k.off(`scroll${y}`, g.event.scroll).off(`scrollchange${y}`, g.event.scrollchange), p.type == "fixed" && (g.resetFixed(), g.remove.placeholder()), S.off(y).removeData(R); },
                        observeChanges() { "MutationObserver" in o && (b = new MutationObserver(g.event.contextChanged), m = new MutationObserver(g.event.changed), b.observe(n, { childList: !0, subtree: !0 }), m.observe(A, { childList: !0, subtree: !0 }), g.debug("Setting up mutation observer", m)); },
                        bind: { events() { g.verbose("Binding visibility events to scroll and resize"), p.refreshOnLoad && V.on(`load${y}`, g.event.load), V.on(`resize${y}`, g.event.resize), k.off(`scroll${y}`).on(`scroll${y}`, g.event.scroll).on(`scrollchange${y}`, g.event.scrollchange); } },
                        event: { changed(e) { g.verbose("DOM tree modified, updating visibility calculations"), g.timer = setTimeout(() => { g.verbose("DOM tree modified, updating sticky menu"), g.refresh(); }, 100); }, contextChanged(o) { [].forEach.call(o, (o) => { o.removedNodes && [].forEach.call(o.removedNodes, (o) => { (o == A || e(o).find(A).length > 0) && (g.debug("Element removed from DOM, tearing down events"), g.destroy()); }); }); }, resize() { g.debug("Window resized"), p.refreshOnResize && O(g.refresh); }, load() { g.debug("Page finished loading"), O(g.refresh); }, scroll() { p.throttle ? (clearTimeout(g.timer), g.timer = setTimeout(() => { k.triggerHandler(`scrollchange${y}`, [k.scrollTop()]); }, p.throttle)) : O(() => { k.triggerHandler(`scrollchange${y}`, [k.scrollTop()]); }); }, scrollchange(e, o) { g.checkVisibility(o); } },
                        precache(o, t) { o instanceof Array || (o = [o]); for (var i = o.length, s = 0, c = [], r = n.createElement("img"), a = function () { ++s >= o.length && e.isFunction(t) && t(); }; i--;)r = n.createElement("img"), r.onload = a, r.onerror = a, r.src = o[i], c.push(r); },
                        enableCallbacks() { g.debug("Allowing callbacks to occur"), z = !1; },
                        disableCallbacks() { g.debug("Disabling all callbacks temporarily"), z = !0; },
                        should: { trackChanges() { return d ? (g.debug("One time query, no need to bind events"), !1) : (g.debug("Callbacks being attached"), !0); } },
                        setup: { cache() { g.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = S.data(C.src); e && (g.verbose("Lazy loading image", e), p.once = !0, p.observeChanges = !1, p.onOnScreen = function () { g.debug("Image on screen", A), g.precache(e, () => { g.set.image(e, function () { v++, v == f && p.onAllLoaded.call(this), p.onLoad.call(this); }); }); }); }, fixed() { g.debug("Setting up fixed"), p.once = !1, p.observeChanges = !1, p.initialCheck = !0, p.refreshOnLoad = !0, t.transition || (p.transition = !1), g.create.placeholder(), g.debug("Added placeholder", s), p.onTopPassed = function () { g.debug("Element passed, adding fixed position", S), g.show.placeholder(), g.set.fixed(), p.transition && void 0 !== e.fn.transition && S.transition(p.transition, p.duration); }, p.onTopPassedReverse = function () { g.debug("Element returned to position, removing fixed", S), g.hide.placeholder(), g.remove.fixed(); }; } },
                        create: { placeholder() { g.verbose("Creating fixed position placeholder"), s = S.clone(!1).css("display", "none").addClass(h.placeholder).insertAfter(S); } },
                        show: { placeholder() { g.verbose("Showing placeholder"), s.css("display", "block").css("visibility", "hidden"); } },
                        hide: { placeholder() { g.verbose("Hiding placeholder"), s.css("display", "none").css("visibility", ""); } },
                        set: { fixed() { g.verbose("Setting element to fixed position"), S.addClass(h.fixed).css({ position: "fixed", top: `${p.offset}px`, left: "auto", zIndex: p.zIndex }), p.onFixed.call(A); }, image(o, n) { if (S.attr("src", o), p.transition) if (void 0 !== e.fn.transition) { if (S.hasClass(h.visible)) return void g.debug("Transition already occurred on this image, skipping animation"); S.transition(p.transition, p.duration, n); } else S.fadeIn(p.duration, n); else S.show(); } },
                        is: { onScreen() { return g.get.elementCalculations().onScreen; }, offScreen() { return g.get.elementCalculations().offScreen; }, visible() { return !(!g.cache || !g.cache.element) && !(g.cache.element.width === 0 && g.cache.element.offset.top === 0); } },
                        refresh() { g.debug("Refreshing constants (width/height)"), p.type == "fixed" && g.resetFixed(), g.reset(), g.save.position(), p.checkOnRefresh && g.checkVisibility(), p.onRefresh.call(A); },
                        resetFixed() { g.remove.fixed(), g.remove.occurred(); },
                        reset() { g.verbose("Resetting all cached values"), e.isPlainObject(g.cache) && (g.cache.screen = {}, g.cache.element = {}); },
                        checkVisibility(e) { g.verbose("Checking visibility of element", g.cache.element), !z && g.is.visible() && (g.save.scroll(e), g.save.calculations(), g.passed(), g.passingReverse(), g.topVisibleReverse(), g.bottomVisibleReverse(), g.topPassedReverse(), g.bottomPassedReverse(), g.onScreen(), g.offScreen(), g.passing(), g.topVisible(), g.bottomVisible(), g.topPassed(), g.bottomPassed(), p.onUpdate && p.onUpdate.call(A, g.get.elementCalculations())); },
                        passed(o, n) { const t = g.get.elementCalculations(); if (o && n)p.onPassed[o] = n; else { if (void 0 !== o) return g.get.pixelsPassed(o) > t.pixelsPassed; t.passing && e.each(p.onPassed, (e, o) => { t.bottomVisible || t.pixelsPassed > g.get.pixelsPassed(e) ? g.execute(o, e) : p.once || g.remove.occurred(o); }); } },
                        onScreen(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onOnScreen; if (e && (g.debug("Adding callback for onScreen", e), p.onOnScreen = e), o.onScreen ? g.execute(n, "onScreen") : p.once || g.remove.occurred("onScreen"), void 0 !== e) return o.onOnScreen;
                        },
                        offScreen(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onOffScreen; if (e && (g.debug("Adding callback for offScreen", e), p.onOffScreen = e), o.offScreen ? g.execute(n, "offScreen") : p.once || g.remove.occurred("offScreen"), void 0 !== e) return o.onOffScreen;
                        },
                        passing(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onPassing; if (e && (g.debug("Adding callback for passing", e), p.onPassing = e), o.passing ? g.execute(n, "passing") : p.once || g.remove.occurred("passing"), void 0 !== e) return o.passing;
                        },
                        topVisible(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onTopVisible; if (e && (g.debug("Adding callback for top visible", e), p.onTopVisible = e), o.topVisible ? g.execute(n, "topVisible") : p.once || g.remove.occurred("topVisible"), void 0 === e) return o.topVisible;
                        },
                        bottomVisible(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onBottomVisible; if (e && (g.debug("Adding callback for bottom visible", e), p.onBottomVisible = e), o.bottomVisible ? g.execute(n, "bottomVisible") : p.once || g.remove.occurred("bottomVisible"), void 0 === e) return o.bottomVisible;
                        },
                        topPassed(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onTopPassed; if (e && (g.debug("Adding callback for top passed", e), p.onTopPassed = e), o.topPassed ? g.execute(n, "topPassed") : p.once || g.remove.occurred("topPassed"), void 0 === e) return o.topPassed;
                        },
                        bottomPassed(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onBottomPassed; if (e && (g.debug("Adding callback for bottom passed", e), p.onBottomPassed = e), o.bottomPassed ? g.execute(n, "bottomPassed") : p.once || g.remove.occurred("bottomPassed"), void 0 === e) return o.bottomPassed;
                        },
                        passingReverse(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onPassingReverse; if (e && (g.debug("Adding callback for passing reverse", e), p.onPassingReverse = e), o.passing ? p.once || g.remove.occurred("passingReverse") : g.get.occurred("passing") && g.execute(n, "passingReverse"), void 0 !== e) return !o.passing;
                        },
                        topVisibleReverse(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onTopVisibleReverse; if (e && (g.debug("Adding callback for top visible reverse", e), p.onTopVisibleReverse = e), o.topVisible ? p.once || g.remove.occurred("topVisibleReverse") : g.get.occurred("topVisible") && g.execute(n, "topVisibleReverse"), void 0 === e) return !o.topVisible;
                        },
                        bottomVisibleReverse(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onBottomVisibleReverse; if (e && (g.debug("Adding callback for bottom visible reverse", e), p.onBottomVisibleReverse = e), o.bottomVisible ? p.once || g.remove.occurred("bottomVisibleReverse") : g.get.occurred("bottomVisible") && g.execute(n, "bottomVisibleReverse"), void 0 === e) return !o.bottomVisible;
                        },
                        topPassedReverse(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onTopPassedReverse; if (e && (g.debug("Adding callback for top passed reverse", e), p.onTopPassedReverse = e), o.topPassed ? p.once || g.remove.occurred("topPassedReverse") : g.get.occurred("topPassed") && g.execute(n, "topPassedReverse"), void 0 === e) return !o.onTopPassed;
                        },
                        bottomPassedReverse(e) {
                            let o = g.get.elementCalculations(),
                                n = e || p.onBottomPassedReverse; if (e && (g.debug("Adding callback for bottom passed reverse", e), p.onBottomPassedReverse = e), o.bottomPassed ? p.once || g.remove.occurred("bottomPassedReverse") : g.get.occurred("bottomPassed") && g.execute(n, "bottomPassedReverse"), void 0 === e) return !o.bottomPassed;
                        },
                        execute(e, o) {
                            let n = g.get.elementCalculations(),
                                t = g.get.screenCalculations(); e = e || !1, e && (p.continuous ? (g.debug("Callback being called continuously", o, n), e.call(A, n, t)) : g.get.occurred(o) || (g.debug("Conditions met", o, n), e.call(A, n, t))), g.save.occurred(o);
                        },
                        remove: { fixed() { g.debug("Removing fixed position"), S.removeClass(h.fixed).css({ position: "", top: "", left: "", zIndex: "" }), p.onUnfixed.call(A); }, placeholder() { g.debug("Removing placeholder content"), s && s.remove(); }, occurred(e) { if (e) { const o = g.cache.occurred; void 0 !== o[e] && o[e] === !0 && (g.debug("Callback can now be called again", e), g.cache.occurred[e] = !1); } else g.cache.occurred = {}; } },
                        save: { calculations() { g.verbose("Saving all calculations necessary to determine positioning"), g.save.direction(), g.save.screenCalculations(), g.save.elementCalculations(); },
                            occurred(e) { e && (void 0 !== g.cache.occurred[e] && g.cache.occurred[e] === !0 || (g.verbose("Saving callback occurred", e), g.cache.occurred[e] = !0)); },
                            scroll(e) { e = e + p.offset || k.scrollTop() + p.offset, g.cache.scroll = e; },
                            direction() {
                                let e,
                                    o = g.get.scroll(),
                                    n = g.get.lastScroll(); return e = o > n && n ? "down" : o < n && n ? "up" : "static", g.cache.direction = e, g.cache.direction;
                            },
                            elementPosition() {
                                let e = g.cache.element,
                                    o = g.get.screenSize(); return g.verbose("Saving element position"), e.fits = e.height < o.height, e.offset = S.offset(), e.width = S.outerWidth(), e.height = S.outerHeight(), g.cache.element = e, e;
                            },
                            elementCalculations() {
                                let e = g.get.screenCalculations(),
                                    o = g.get.elementPosition(); return p.includeMargin ? (o.margin = {}, o.margin.top = parseInt(S.css("margin-top"), 10), o.margin.bottom = parseInt(S.css("margin-bottom"), 10), o.top = o.offset.top - o.margin.top, o.bottom = o.offset.top + o.height + o.margin.bottom) : (o.top = o.offset.top, o.bottom = o.offset.top + o.height), o.topVisible = e.bottom >= o.top, o.topPassed = e.top >= o.top, o.bottomVisible = e.bottom >= o.bottom, o.bottomPassed = e.top >= o.bottom, o.pixelsPassed = 0, o.percentagePassed = 0, o.onScreen = o.topVisible && !o.bottomPassed, o.passing = o.topPassed && !o.bottomPassed, o.offScreen = !o.onScreen, o.passing && (o.pixelsPassed = e.top - o.top, o.percentagePassed = (e.top - o.top) / o.height), g.cache.element = o, g.verbose("Updated element calculations", o), o;
                            },
                            screenCalculations() { const e = g.get.scroll(); return g.save.direction(), g.cache.screen.top = e, g.cache.screen.bottom = e + g.cache.screen.height, g.cache.screen; },
                            screenSize() { g.verbose("Saving window position"), g.cache.screen = { height: k.height() }; },
                            position() { g.save.screenSize(), g.save.elementPosition(); } },
                        get: { pixelsPassed(e) { const o = g.get.elementCalculations(); return e.search("%") > -1 ? o.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return void 0 !== g.cache.occurred && (g.cache.occurred[e] || !1); }, direction() { return void 0 === g.cache.direction && g.save.direction(), g.cache.direction; }, elementPosition() { return void 0 === g.cache.element && g.save.elementPosition(), g.cache.element; }, elementCalculations() { return void 0 === g.cache.element && g.save.elementCalculations(), g.cache.element; }, screenCalculations() { return void 0 === g.cache.screen && g.save.screenCalculations(), g.cache.screen; }, screenSize() { return void 0 === g.cache.screen && g.save.screenSize(), g.cache.screen; }, scroll() { return void 0 === g.cache.scroll && g.save.scroll(), g.cache.scroll; }, lastScroll() { return void 0 === g.cache.screen ? (g.debug("First scroll event, no last scroll could be found"), !1) : g.cache.screen.top; } },
                        setting(o, n) { if (e.isPlainObject(o))e.extend(!0, p, o); else { if (void 0 === n) return p[o]; p[o] = n; } },
                        internal(o, n) { if (e.isPlainObject(o))e.extend(!0, g, o); else { if (void 0 === n) return g[o]; g[o] = n; } },
                        debug() { !p.silent && p.debug && (p.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.debug.apply(console, arguments))); },
                        verbose() { !p.silent && p.verbose && p.debug && (p.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.verbose.apply(console, arguments))); },
                        error() { p.silent || (g.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), g.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let o,
                                n,
                                t; p.performance && (o = (new Date()).getTime(), t = r || o, n = o - t, r = o, a.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: A, "Execution Time": n })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500);
                        },
                            display() {
                                let o = `${p.name}:`,
                                    n = 0; r = !1, clearTimeout(g.performance.timer), e.each(a, (e, o) => { n += o["Execution Time"]; }), o += ` ${n}ms`, c && (o += ` '${c}'`), (void 0 !== console.group || void 0 !== console.table) && a.length > 0 && (console.groupCollapsed(o), console.table ? console.table(a) : e.each(a, (e, o) => { console.log(`${o.Name}: ${o["Execution Time"]}ms`); }), console.groupEnd()), a = [];
                            } },
                        invoke(o, n, t) {
                            let s,
                                c,
                                r,
                                a = T; return n = n || u, t = A || t, typeof o === "string" && void 0 !== a && (o = o.split(/[\. ]/), s = o.length - 1, e.each(o, (n, t) => { const i = n != s ? t + o[n + 1].charAt(0).toUpperCase() + o[n + 1].slice(1) : o; if (e.isPlainObject(a[i]) && n != s)a = a[i]; else { if (void 0 !== a[i]) return c = a[i], !1; if (!e.isPlainObject(a[t]) || n == s) return void 0 !== a[t] ? (c = a[t], !1) : (g.error(x.method, o), !1); a = a[t]; } })), e.isFunction(c) ? r = c.apply(t, n) : void 0 !== c && (r = c), e.isArray(i) ? i.push(r) : void 0 !== i ? i = [i, r] : void 0 !== r && (i = r), c;
                        } }, d ? (void 0 === T && g.initialize(), T.save.scroll(), T.save.calculations(), g.invoke(l)) : (void 0 !== T && T.invoke("destroy"), g.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.visibility.settings = { name: "Visibility", namespace: "visibility", debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: o, throttle: !1, type: !1, zIndex: "10", transition: "fade in", duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onLoad() {}, onAllLoaded() {}, onFixed() {}, onUnfixed() {}, onUpdate: !1, onRefresh() {}, metadata: { src: "src" }, className: { fixed: "fixed", placeholder: "placeholder", visible: "visible" }, error: { method: "The method you called is not defined.", visible: "Element is hidden, you must call refresh after element becomes visible" } };
}(jQuery, window, document));
