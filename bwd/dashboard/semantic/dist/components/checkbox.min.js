/*!
 * # Semantic UI 2.2.9 - Checkbox
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, n, i, t) {
    n = void 0 !== n && n.Math == Math ? n : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.checkbox = function (t) {
        let o,
            a = e(this),
            c = a.selector || "",
            r = (new Date()).getTime(),
            d = [],
            l = arguments[0],
            s = typeof l === "string",
            u = [].slice.call(arguments, 1); return a.each(function () {
                let a,
                    b,
                    h = e.extend(!0, {}, e.fn.checkbox.settings, t),
                    g = h.className,
                    f = h.namespace,
                    p = h.selector,
                    k = h.error,
                    m = `.${f}`,
                    v = `module-${f}`,
                    y = e(this),
                    C = e(this).children(p.label),
                    x = e(this).children(p.input),
                    w = x[0],
                    I = !1,
                    D = !1,
                    S = y.data(v),
                    E = this; b = { initialize() { b.verbose("Initializing checkbox", h), b.create.label(), b.bind.events(), b.set.tabbable(), b.hide.input(), b.observeChanges(), b.instantiate(), b.setup(); },
                        instantiate() { b.verbose("Storing instance of module", b), S = b, y.data(v, b); },
                        destroy() { b.verbose("Destroying module"), b.unbind.events(), b.show.input(), y.removeData(v); },
                        fix: { reference() { y.is(p.input) && (b.debug("Behavior called on <input> adjusting invoked element"), y = y.closest(p.checkbox), b.refresh()); } },
                        setup() { b.set.initialLoad(), b.is.indeterminate() ? (b.debug("Initial value is indeterminate"), b.indeterminate()) : b.is.checked() ? (b.debug("Initial value is checked"), b.check()) : (b.debug("Initial value is unchecked"), b.uncheck()), b.remove.initialLoad(); },
                        refresh() { C = y.children(p.label), x = y.children(p.input), w = x[0]; },
                        hide: { input() { b.verbose("Modifying <input> z-index to be unselectable"), x.addClass(g.hidden); } },
                        show: { input() { b.verbose("Modifying <input> z-index to be selectable"), x.removeClass(g.hidden); } },
                        observeChanges() { "MutationObserver" in n && (a = new MutationObserver((e) => { b.debug("DOM tree modified, updating selector cache"), b.refresh(); }), a.observe(E, { childList: !0, subtree: !0 }), b.debug("Setting up mutation observer", a)); },
                        attachEvents(n, i) { const t = e(n); i = e.isFunction(b[i]) ? b[i] : b.toggle, t.length > 0 ? (b.debug("Attaching checkbox events to element", n, i), t.on(`click${m}`, i)) : b.error(k.notFound); },
                        event: { click(n) { const i = e(n.target); return i.is(p.input) ? void b.verbose("Using default check action on initialized checkbox") : i.is(p.link) ? void b.debug("Clicking link inside checkbox, skipping toggle") : (b.toggle(), x.focus(), void n.preventDefault()); },
                            keydown(e) {
                                let n = e.which,
                                    i = { enter: 13, space: 32, escape: 27 }; n == i.escape ? (b.verbose("Escape key pressed blurring field"), x.blur(), D = !0) : e.ctrlKey || n != i.space && n != i.enter ? D = !1 : (b.verbose("Enter/space key pressed, toggling checkbox"), b.toggle(), D = !0);
                            },
                            keyup(e) { D && e.preventDefault(); } },
                        check() { b.should.allowCheck() && (b.debug("Checking checkbox", x), b.set.checked(), b.should.ignoreCallbacks() || (h.onChecked.call(w), h.onChange.call(w))); },
                        uncheck() { b.should.allowUncheck() && (b.debug("Unchecking checkbox"), b.set.unchecked(), b.should.ignoreCallbacks() || (h.onUnchecked.call(w), h.onChange.call(w))); },
                        indeterminate() { if (b.should.allowIndeterminate()) return void b.debug("Checkbox is already indeterminate"); b.debug("Making checkbox indeterminate"), b.set.indeterminate(), b.should.ignoreCallbacks() || (h.onIndeterminate.call(w), h.onChange.call(w)); },
                        determinate() { if (b.should.allowDeterminate()) return void b.debug("Checkbox is already determinate"); b.debug("Making checkbox determinate"), b.set.determinate(), b.should.ignoreCallbacks() || (h.onDeterminate.call(w), h.onChange.call(w)); },
                        enable() { if (b.is.enabled()) return void b.debug("Checkbox is already enabled"); b.debug("Enabling checkbox"), b.set.enabled(), h.onEnable.call(w), h.onEnabled.call(w); },
                        disable() { if (b.is.disabled()) return void b.debug("Checkbox is already disabled"); b.debug("Disabling checkbox"), b.set.disabled(), h.onDisable.call(w), h.onDisabled.call(w); },
                        get: { radios() { return e(`input[name="${b.get.name()}"]`).closest(p.checkbox); }, otherRadios() { return b.get.radios().not(y); }, name() { return x.attr("name"); } },
                        is: { initialLoad() { return I; }, radio() { return x.hasClass(g.radio) || x.attr("type") == "radio"; }, indeterminate() { return void 0 !== x.prop("indeterminate") && x.prop("indeterminate"); }, checked() { return void 0 !== x.prop("checked") && x.prop("checked"); }, disabled() { return void 0 !== x.prop("disabled") && x.prop("disabled"); }, enabled() { return !b.is.disabled(); }, determinate() { return !b.is.indeterminate(); }, unchecked() { return !b.is.checked(); } },
                        should: { allowCheck() { return b.is.determinate() && b.is.checked() && !b.should.forceCallbacks() ? (b.debug("Should not allow check, checkbox is already checked"), !1) : h.beforeChecked.apply(w) !== !1 || (b.debug("Should not allow check, beforeChecked cancelled"), !1); }, allowUncheck() { return b.is.determinate() && b.is.unchecked() && !b.should.forceCallbacks() ? (b.debug("Should not allow uncheck, checkbox is already unchecked"), !1) : h.beforeUnchecked.apply(w) !== !1 || (b.debug("Should not allow uncheck, beforeUnchecked cancelled"), !1); }, allowIndeterminate() { return b.is.indeterminate() && !b.should.forceCallbacks() ? (b.debug("Should not allow indeterminate, checkbox is already indeterminate"), !1) : h.beforeIndeterminate.apply(w) !== !1 || (b.debug("Should not allow indeterminate, beforeIndeterminate cancelled"), !1); }, allowDeterminate() { return b.is.determinate() && !b.should.forceCallbacks() ? (b.debug("Should not allow determinate, checkbox is already determinate"), !1) : h.beforeDeterminate.apply(w) !== !1 || (b.debug("Should not allow determinate, beforeDeterminate cancelled"), !1); }, forceCallbacks() { return b.is.initialLoad() && h.fireOnInit; }, ignoreCallbacks() { return I && !h.fireOnInit; } },
                        can: { change() { return !(y.hasClass(g.disabled) || y.hasClass(g.readOnly) || x.prop("disabled") || x.prop("readonly")); }, uncheck() { return typeof h.uncheckable === "boolean" ? h.uncheckable : !b.is.radio(); } },
                        set: { initialLoad() { I = !0; }, checked() { if (b.verbose("Setting class to checked"), y.removeClass(g.indeterminate).addClass(g.checked), b.is.radio() && b.uncheckOthers(), !b.is.indeterminate() && b.is.checked()) return void b.debug("Input is already checked, skipping input property change"); b.verbose("Setting state to checked", w), x.prop("indeterminate", !1).prop("checked", !0), b.trigger.change(); }, unchecked() { if (b.verbose("Removing checked class"), y.removeClass(g.indeterminate).removeClass(g.checked), !b.is.indeterminate() && b.is.unchecked()) return void b.debug("Input is already unchecked"); b.debug("Setting state to unchecked"), x.prop("indeterminate", !1).prop("checked", !1), b.trigger.change(); }, indeterminate() { if (b.verbose("Setting class to indeterminate"), y.addClass(g.indeterminate), b.is.indeterminate()) return void b.debug("Input is already indeterminate, skipping input property change"); b.debug("Setting state to indeterminate"), x.prop("indeterminate", !0), b.trigger.change(); }, determinate() { if (b.verbose("Removing indeterminate class"), y.removeClass(g.indeterminate), b.is.determinate()) return void b.debug("Input is already determinate, skipping input property change"); b.debug("Setting state to determinate"), x.prop("indeterminate", !1); }, disabled() { if (b.verbose("Setting class to disabled"), y.addClass(g.disabled), b.is.disabled()) return void b.debug("Input is already disabled, skipping input property change"); b.debug("Setting state to disabled"), x.prop("disabled", "disabled"), b.trigger.change(); }, enabled() { if (b.verbose("Removing disabled class"), y.removeClass(g.disabled), b.is.enabled()) return void b.debug("Input is already enabled, skipping input property change"); b.debug("Setting state to enabled"), x.prop("disabled", !1), b.trigger.change(); }, tabbable() { b.verbose("Adding tabindex to checkbox"), void 0 === x.attr("tabindex") && x.attr("tabindex", 0); } },
                        remove: { initialLoad() { I = !1; } },
                        trigger: { change() {
                            let e = i.createEvent("HTMLEvents"),
                                n = x[0]; n && (b.verbose("Triggering native change event"), e.initEvent("change", !0, !1), n.dispatchEvent(e));
                        } },
                        create: { label() { x.prevAll(p.label).length > 0 ? (x.prev(p.label).detach().insertAfter(x), b.debug("Moving existing label", C)) : b.has.label() || (C = e("<label>").insertAfter(x), b.debug("Creating label", C)); } },
                        has: { label() { return C.length > 0; } },
                        bind: { events() { b.verbose("Attaching checkbox events"), y.on(`click${m}`, b.event.click).on(`keydown${m}`, p.input, b.event.keydown).on(`keyup${m}`, p.input, b.event.keyup); } },
                        unbind: { events() { b.debug("Removing events"), y.off(m); } },
                        uncheckOthers() { const e = b.get.otherRadios(); b.debug("Unchecking other radios", e), e.removeClass(g.checked); },
                        toggle() { if (!b.can.change()) return void (b.is.radio() || b.debug("Checkbox is read-only or disabled, ignoring toggle")); b.is.indeterminate() || b.is.unchecked() ? (b.debug("Currently unchecked"), b.check()) : b.is.checked() && b.can.uncheck() && (b.debug("Currently checked"), b.uncheck()); },
                        setting(n, i) { if (b.debug("Changing setting", n, i), e.isPlainObject(n))e.extend(!0, h, n); else { if (void 0 === i) return h[n]; e.isPlainObject(h[n]) ? e.extend(!0, h[n], i) : h[n] = i; } },
                        internal(n, i) { if (e.isPlainObject(n))e.extend(!0, b, n); else { if (void 0 === i) return b[n]; b[n] = i; } },
                        debug() { !h.silent && h.debug && (h.performance ? b.performance.log(arguments) : (b.debug = Function.prototype.bind.call(console.info, console, `${h.name}:`), b.debug.apply(console, arguments))); },
                        verbose() { !h.silent && h.verbose && h.debug && (h.performance ? b.performance.log(arguments) : (b.verbose = Function.prototype.bind.call(console.info, console, `${h.name}:`), b.verbose.apply(console, arguments))); },
                        error() { h.silent || (b.error = Function.prototype.bind.call(console.error, console, `${h.name}:`), b.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let n,
                                i,
                                t; h.performance && (n = (new Date()).getTime(), t = r || n, i = n - t, r = n, d.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: E, "Execution Time": i })), clearTimeout(b.performance.timer), b.performance.timer = setTimeout(b.performance.display, 500);
                        },
                            display() {
                                let n = `${h.name}:`,
                                    i = 0; r = !1, clearTimeout(b.performance.timer), e.each(d, (e, n) => { i += n["Execution Time"]; }), n += ` ${i}ms`, c && (n += ` '${c}'`), (void 0 !== console.group || void 0 !== console.table) && d.length > 0 && (console.groupCollapsed(n), console.table ? console.table(d) : e.each(d, (e, n) => { console.log(`${n.Name}: ${n["Execution Time"]}ms`); }), console.groupEnd()), d = [];
                            } },
                        invoke(n, i, t) {
                            let a,
                                c,
                                r,
                                d = S; return i = i || u, t = E || t, typeof n === "string" && void 0 !== d && (n = n.split(/[\. ]/), a = n.length - 1, e.each(n, (i, t) => { const o = i != a ? t + n[i + 1].charAt(0).toUpperCase() + n[i + 1].slice(1) : n; if (e.isPlainObject(d[o]) && i != a)d = d[o]; else { if (void 0 !== d[o]) return c = d[o], !1; if (!e.isPlainObject(d[t]) || i == a) return void 0 !== d[t] ? (c = d[t], !1) : (b.error(k.method, n), !1); d = d[t]; } })), e.isFunction(c) ? r = c.apply(t, i) : void 0 !== c && (r = c), e.isArray(o) ? o.push(r) : void 0 !== o ? o = [o, r] : void 0 !== r && (o = r), c;
                        } }, s ? (void 0 === S && b.initialize(), b.invoke(l)) : (void 0 !== S && S.invoke("destroy"), b.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.checkbox.settings = { name: "Checkbox", namespace: "checkbox", silent: !1, debug: !1, verbose: !0, performance: !0, uncheckable: "auto", fireOnInit: !1, onChange() {}, beforeChecked() {}, beforeUnchecked() {}, beforeDeterminate() {}, beforeIndeterminate() {}, onChecked() {}, onUnchecked() {}, onDeterminate() {}, onIndeterminate() {}, onEnable() {}, onDisable() {}, onEnabled() {}, onDisabled() {}, className: { checked: "checked", indeterminate: "indeterminate", disabled: "disabled", hidden: "hidden", radio: "radio", readOnly: "read-only" }, error: { method: "The method you called is not defined" }, selector: { checkbox: ".ui.checkbox", label: "label, .box", input: "input[type=\"checkbox\"], input[type=\"radio\"]", link: "a[href]" } };
}(jQuery, window, document));
